import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../infrastructure/prisma.service';
import Utils from '../../utils';
import { VisualizationViewType } from '../../schemas/graphql.autogenerated';
import { CARBONABLE_COMPANY_ID } from '../carbon-credits/carbon-credits.resolver';

type Percentages = {
  blue_count: string;
  orange_count: string;
  green_count: string;
  avoidance: string;
  removal: string;
};

type KVPercent = {
  key: string;
  value_percent: string;
};

type LocalizationRepartition = {
  name: string;
  iso: string;
  flag: string;
  value_percent: string;
};

type ProjectMetricsVisualizationData = {
  percentagesArr: Percentages[];
  certifiersArr: KVPercent[];
  countriesArr: LocalizationRepartition[];
};

@Injectable()
export class ProjectMetricsService {
  constructor(private prismaClient: PrismaService) {}

  async get(view: VisualizationViewType): Promise<any> {
    const { percentagesArr, certifiersArr, countriesArr } =
      await this.fetchDataFromView(view);

    const percentages = percentagesArr.shift();
    const standards = certifiersArr.map((c) => ({
      ...c,
      value: Utils.formatString({
        value: c.value_percent,
        suffix: '%',
      }),
    }));
    const localization = countriesArr.map((c) => ({
      country: { name: c.name, iso: c.iso, flag: c.flag },
      value: Utils.formatString({
        value: c.value_percent,
        suffix: '%',
      }),
    }));
    return {
      colors: {
        green: {
          key: 'Forest & Wetland',
          value: Utils.formatString({
            value: percentages.green_count,
            suffix: '%',
          }),
        },
        orange: {
          key: 'Agro & Soil',
          value: Utils.formatString({
            value: percentages.orange_count,
            suffix: '%',
          }),
        },
        blue: {
          key: 'Coasts & Submarine',
          value: Utils.formatString({
            value: percentages.blue_count,
            suffix: '%',
          }),
        },
      },
      types: {
        avoidance: Utils.formatString({
          value: percentages.avoidance,
          suffix: '%',
        }),
        removal: Utils.formatString({
          value: percentages.removal,
          suffix: '%',
        }),
      },
      standards,
      localization,
    };
  }

  async fetchDataFromView(
    view: VisualizationViewType,
  ): Promise<ProjectMetricsVisualizationData> {
    if (view?.company_id) {
      return await this.fetchCompanyWide(view.company_id);
    }
    if (view?.business_unit_id) {
      return await this.fetchBusinessUnitWide(view.business_unit_id);
    }
    if (view?.project_id) {
      return await this.fetchProjectWide(view.project_id);
    }

    return await this.fetchCompanyWide(CARBONABLE_COMPANY_ID);
  }

  async fetchCompanyWide(
    companyId: string,
  ): Promise<ProjectMetricsVisualizationData> {
    const percentagesArr = await this.prismaClient.$queryRaw<Percentages[]>`
SELECT
    AVG((p.color = 'BLUE')::int) * 100 as blue_count,
    AVG((p.color = 'GREEN')::int) * 100 as green_count,
    AVG((p.color = 'ORANGE')::int) * 100 as orange_count,
    AVG((p.type = 'CONSERVATION')::int) * 100 as avoidance,
    AVG((p.type = 'RESTORATION')::int) * 100 as removal
FROM projects p
WHERE p.company_id = ${companyId}
LIMIT 1
;
        `;
    const certifiersArr = await this.prismaClient.$queryRaw<KVPercent[]>`
SELECT c.name as key, (count(*) / tablestat.total::float) * 100 AS value_percent
FROM projects p
         INNER JOIN certifier c on c.id = p.certifier_id
         CROSS JOIN (SELECT count(*) AS total FROM projects p) AS tablestat
WHERE p.company_id = ${companyId}
GROUP BY tablestat.total, c.name
;
        `;

    const countriesArr = await this.prismaClient.$queryRaw<
      LocalizationRepartition[]
    >`
SELECT c.name as name, c.data->'cca2' as iso, c.data->'flag' as flag, (count(*) / tablestat.total::float) * 100 AS value_percent
FROM projects p
INNER JOIN country c on c.id = p.country_id
CROSS JOIN (SELECT count(*) AS total FROM projects p) AS tablestat
WHERE p.company_id = ${companyId}
GROUP BY tablestat.total, c.name, c.data
;
        `;

    return { percentagesArr, certifiersArr, countriesArr };
  }

  async fetchBusinessUnitWide(
    businessUnitId: string,
  ): Promise<ProjectMetricsVisualizationData> {
    const percentagesArr = await this.prismaClient.$queryRaw<Percentages[]>`
SELECT
    AVG((p.color = 'BLUE')::int) * 100 as blue_count,
    AVG((p.color = 'GREEN')::int) * 100 as green_count,
    AVG((p.color = 'ORANGE')::int) * 100 as orange_count,
    AVG((p.type = 'CONSERVATION')::int) * 100 as avoidance,
    AVG((p.type = 'RESTORATION')::int) * 100 as removal
FROM projects p
INNER JOIN allocation a on a.project_id = p.id
INNER JOIN business_unit bu on bu.id = a.business_unit_id
WHERE bu.id = ${businessUnitId}
LIMIT 1
;
        `;
    const certifiersArr = await this.prismaClient.$queryRaw<KVPercent[]>`
SELECT c.name as key, (count(*) / tablestat.total::float) * 100 AS value_percent
FROM projects p
         INNER JOIN certifier c on c.id = p.certifier_id
         CROSS JOIN (SELECT count(*) AS total FROM projects p INNER JOIN allocation a2 on p.id = a2.project_id INNER JOIN business_unit b on a2.business_unit_id = b.id) AS tablestat
         INNER JOIN allocation a on a.project_id = p.id
         INNER JOIN business_unit bu on bu.id = a.business_unit_id
         WHERE bu.id = ${businessUnitId}
GROUP BY tablestat.total, c.name
;
        `;

    const countriesArr = await this.prismaClient.$queryRaw<
      LocalizationRepartition[]
    >`
SELECT c.name as name, c.data->'cca2' as iso, c.data->'flag' as flag, (count(*) / tablestat.total::float) * 100 AS value_percent
FROM projects p
INNER JOIN allocation a on a.project_id = p.id
INNER JOIN business_unit bu on bu.id = a.business_unit_id
INNER JOIN country c on c.id = p.country_id
CROSS JOIN (SELECT count(*) AS total FROM projects p INNER JOIN allocation a2 on p.id = a2.project_id INNER JOIN business_unit b on a2.business_unit_id = b.id INNER JOIN country c2 on c2.id = p.country_id) AS tablestat
WHERE bu.id = ${businessUnitId}
GROUP BY tablestat.total, c.name, c.data
;
        `;

    return { percentagesArr, certifiersArr, countriesArr };
  }

  async fetchProjectWide(
    projectId: string,
  ): Promise<ProjectMetricsVisualizationData> {
    const percentagesArr = await this.prismaClient.$queryRaw<Percentages[]>`
SELECT
    AVG((p.color = 'BLUE')::int) * 100 as blue_count,
    AVG((p.color = 'GREEN')::int) * 100 as green_count,
    AVG((p.color = 'ORANGE')::int) * 100 as orange_count,
    AVG((p.origin = 'DIRECT_PURCHASE')::int) * 100 as avoidance,
    AVG((p.origin = 'FORWARD_FINANCE')::int) * 100 as removal
FROM projects p
WHERE p.id = ${projectId}
LIMIT 1
;
        `;
    const certifiersArr = await this.prismaClient.$queryRaw<KVPercent[]>`
SELECT c.name as key, (count(*) / tablestat.total::float) * 100 AS value_percent
FROM projects p
         INNER JOIN certifier c on c.id = p.certifier_id
         CROSS JOIN (SELECT count(*) AS total FROM projects p) AS tablestat
        WHERE p.id = ${projectId}
GROUP BY tablestat.total, c.name
;
        `;

    const countriesArr = await this.prismaClient.$queryRaw<
      LocalizationRepartition[]
    >`
SELECT c.name as name, c.data->'cca2' as iso, c.data->'flag' as flag, (count(*) / tablestat.total::float) * 100 AS value_percent
FROM projects p
INNER JOIN country c on c.id = p.country_id
CROSS JOIN (SELECT count(*) AS total FROM projects p) AS tablestat
WHERE p.id = ${projectId}
GROUP BY tablestat.total, c.name, c.data
;
        `;

    return { percentagesArr, certifiersArr, countriesArr };
  }
}

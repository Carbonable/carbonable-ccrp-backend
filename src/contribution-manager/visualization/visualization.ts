import * as _ from 'lodash';
import { Args, Resolver, Query } from '@nestjs/graphql';
import {
  VISUALIZATION_REPOSITORY,
  VisualizationRepositoryInterface,
} from '../../domain/allocation';
import { Inject, Logger } from '@nestjs/common';
import {
  VisualizationStrategyKeyInput,
  annualPlanningKey,
  cumulativePlanningKey,
  financialAnalysisKey,
  netZeroKey,
} from '../../domain/allocation/visualization/utils';
import { VisualizationViewType } from '../../schemas/graphql.autogenerated';
import Utils from '../../utils';
import {
  AnnualPlanningVisualizationStrategy,
  CumulativePlanningVisualizationStrategy,
  NetZeroVisualizationStrategy,
} from '../../domain/allocation/visualization';
import { FinancialAnalysisVisualizationStrategy } from '../../domain/allocation/visualization/financial-analysis.strategy';
import { Public } from '../../auth/auth.public.decorator';

@Resolver('Visualization')
export class VisualizationResolver {
  logger = new Logger(VisualizationResolver.name);
  constructor(
    @Inject(VISUALIZATION_REPOSITORY)
    private readonly repository: VisualizationRepositoryInterface,
    private readonly netZeroStrategy: NetZeroVisualizationStrategy,
    private readonly annualPlannigStrategy: AnnualPlanningVisualizationStrategy,
    private readonly cumulativePlannigStrategy: CumulativePlanningVisualizationStrategy,
    private readonly financialAnalysisStrategy: FinancialAnalysisVisualizationStrategy,
  ) {}

  @Public()
  @Query()
  async netZeroPlanning(@Args('view') view: any) {
    const data = await getVisualizationView(netZeroKey)(
      this.repository,
      view as VisualizationViewType,
    );

    if (data.length === 0 || process.env.SHOULD_CACHE) {
      await this.netZeroStrategy.hydrateFromViewType(view);
    }

    return await getVisualizationView(netZeroKey)(
      this.repository,
      view as VisualizationViewType,
    );
  }

  @Public()
  @Query()
  async annual(@Args('view') view: any, @Args('pagination') pagination: any) {
    const data = await getVisualizationView(annualPlanningKey)(
      this.repository,
      view as VisualizationViewType,
    );

    if (data.length === 0 || process.env.SHOULD_CACHE) {
      await this.annualPlannigStrategy.hydrateFromViewType(view);
    }

    return Utils.paginate(
      await getVisualizationView(annualPlanningKey)(
        this.repository,
        view as VisualizationViewType,
      ),
      pagination,
    );
  }

  @Public()
  @Query()
  async cumulative(
    @Args('view') view: any,
    @Args('pagination') pagination: any,
  ) {
    const data = await getVisualizationView(cumulativePlanningKey)(
      this.repository,
      view as VisualizationViewType,
    );

    if (data.length === 0 || process.env.SHOULD_CACHE) {
      await this.cumulativePlannigStrategy.hydrateFromViewType(view);
    }
    return Utils.paginate(
      await getVisualizationView(cumulativePlanningKey)(
        this.repository,
        view as VisualizationViewType,
      ),
      pagination,
    );
  }

  @Public()
  @Query()
  async financialAnalysis(
    @Args('view') view: any,
    @Args('pagination') pagination: any,
  ) {
    const data = await getVisualizationView(financialAnalysisKey)(
      this.repository,
      view as VisualizationViewType,
    );

    if (data.length === 0 || process.env.SHOULD_CACHE) {
      await this.financialAnalysisStrategy.hydrateFromViewType(view);
    }

    return Utils.paginate(
      await getVisualizationView(financialAnalysisKey)(
        this.repository,
        view as VisualizationViewType,
      ),
      pagination,
    );
  }
}

function getVisualizationView(
  viewKey: (input: VisualizationStrategyKeyInput) => string,
) {
  return async function (
    repository: VisualizationRepositoryInterface,
    view: VisualizationViewType,
  ) {
    // converting snakecase to camelCase
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const camelized = _.mapKeys(view, (_v: string, k: string) =>
      _.camelCase(k),
    );
    const res = await repository.get(
      viewKey(camelized as VisualizationStrategyKeyInput),
    );
    if (!res) {
      return [];
    }

    return _.values(
      _.mapValues(JSON.parse(res), (item) => {
        return _.mapKeys(item, (_v: any, k: string) => _.snakeCase(k));
      }),
    );
  };
}

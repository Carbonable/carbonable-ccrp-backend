type Query {
    countries: [Country]
    projects: [Project]
    businessUnits: [BusinessUnit]
    businessUnitDetails(id: String!): BusinessUnit
    countryBy(field: String!, value: String!): Country
    businessUnitsBy(field: String!, value: String!): [BusinessUnit]

    certifierBy(field: String!, value: String!): Certifier
    projectBy(field: String!, value: String!): Project
    availableToAllocate(project_id: String!, business_unit_id: String!): AllocationAvailability

    getGlobalData(view: VisualizationViewType): GlobalData,
    getProjectFundingAllocation(view: VisualizationViewType): ProjectedFundingAllocationWithPagination
    getProjectMetrics(view: VisualizationViewType): ProjectMetrics!
    getImpactMetrics(view: VisualizationViewType): ImpactMetrics!
    companyCarbonAssetAllocation(id: String!): [CompanyCarbonAssetAllocation]
    projectCarbonAssetAllocation(id: String!): [ProjectCarbonAssetAllocation]
    businessUnitCarbonAssetAllocation(id: String!): [BusinessUnitCarbonAssetAllocation]


    netZeroPlanning(view: VisualizationViewType): [NetZeroPlanning]!
    annual(view: VisualizationViewType!): [Annual]!
    cumulative(view: VisualizationViewType!): [Cumulative]!
    financialAnalysis(view: VisualizationViewType!): [FinancialAnalysis]!
}

type Mutation {
    createBusinessUnit(request: CreateBusinessUnitRequest!): DomainResponse
    createForecastedEmissions(request: CreateForecastedEmissionsRequest!): DomainResponse
    createForecastedTargets(request: CreateForecastedTargetsRequest!): DomainResponse
    addAllocations(request: [AddAllocationRequestItem]!): AddAllocationResponse
}

type DomainResponse {
    id: String!
    errors: [String]
}

type Map {
    key: String!
    value: String!
}

type StrIntMap {
    key: String!
    value: Int!
}

type Sdg {
    number: Int!
    name: String!
}

enum ProjectedDecarbonationViewType {
    OFFSET_TYPE
    PROJECT_TYPE
    INVESTMENT_TYPE
}

type GlobalData {
    target: String!
    actual: String!
    debt: String!
    invested_amount: String!
    number_of_projects: String!
}

type CompanyCarbonAssetAllocation {
    project_name: String
    business_units: [AssetAllocationItem]
    type: String
    total_potential: Int
    ex_post_to_date: Int
    ex_ante_to_date: Int
    project_completion: String
    total_allocated_to_date: Int
    total_available_to_date: Int
    allocation_rate: String
    price: Int
    total_amount: Int
}

type AssetAllocationItem {
    id: String!
    name: String!
    metadata: [Map]!
}
type ProjectCarbonAssetAllocation {
  business_unit: AssetAllocationItem!
  allocated: Int
  allocation_amount: Int
  target: Int
  actual: Int
  start_date: String
}
type BusinessUnitCarbonAssetAllocation {
  project: AssetAllocationItem!
  total_cu: Int
  allocated: Int
  generated: Int
  forward: Int
  retired: Int
}

type ProjectedDecarbonation {
    year: String!
    emissions: String!
    received_cc: String!
    purchased_cc: String!
    forward_cc: String!
    retired_cc: String!
    target: String!
    delta: String
}

type ProjectedDecarbonationGraph {
    year: String!
    emissions: Int!
    target: Int!
    data: [StrIntMap]!
}

type ProjectedDecarbonationWithPagination {
    data: [ProjectedDecarbonation!]!
    pagination: PaginationObject
}

type ProjectFundingAllocation {
    id: ID!
    name: String!
    color: String!
    allocation:  String!
    generated_cc: String!
    forwarded_cc: String!
    comitted_cc: String!
    retired_cc: String!
}

type ProjectedFundingAllocationWithPagination {
    data: [ProjectFundingAllocation!]!
    pagination: PaginationObject
}

type ProjectMetrics {
    colors: ProjectColorRepartition!
    types: ProjectTypeRepartition!
    standards: [Map!]!
    localization: [LocalizationRepartition!]!
}

type LocalizationRepartition {
    country: ShortCountry!
    value: String!
}

type ShortCountry {
    name: String!
    iso: String!
    flag: String!
}

type ImpactMetrics {
    sdgs: [Sdg!]!
    removed_tons: String!
    protected_forest: String!
    protected_species: String!
}

type PaginationObject {
    max_page: Int!
    page_number: Int!
    count: Int!
}

input Pagination {
    page: Int
    count: Int
}
